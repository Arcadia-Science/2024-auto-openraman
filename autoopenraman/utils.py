import csv
import json
from pathlib import Path
from typing import Any, Iterable, Optional

import numpy as np


def image_to_spectrum(img: np.ndarray) -> np.ndarray:
    """
    Convert 2D image to spectrum, assuming that averaging is done on the y-axis (second).

    Parameters:
        img (np.ndarray): A 2D image array

    Returns:
        np.ndarray: A 1D array representing the spectrum
    """

    # remove singleton dimensions, if any
    img = img.squeeze()
    # if 3d array, throw error
    if len(img.shape) != 2:
        raise ValueError(f"The input image should be a 2D array. It is a {len(img.shape)}D array.")

    return img.mean(axis=0)


def write_spectrum(
    file_path: Path, x: Iterable[float], y: Iterable[float], header: Optional[list] = None
) -> None:
    """
    Write a 2-column CSV file of x and y

    Parameters:
        file_path (str): The name of the file to write to.
        x (Iterable): An Iterable of pixel values.
        y (Iterable): An Iterable of intensity values corresponding to each pixel.
        header (list, optional): A list of header values. Defaults to `["Pixel", "Intensity"]`.
    """
    # Check if the lengths of the arrays match
    if header is None:
        header = ["Pixel", "Intensity"]
    if len(x) != len(y):
        raise ValueError("The length of x and y arrays must be the same.")

    with open(file_path, mode="w", newline="") as file:
        writer = csv.writer(file)
        # Write the header
        writer.writerow(header)
        # Write the data rows
        for pixel, intensity in zip(x, y):
            writer.writerow([pixel, intensity])


def extract_stage_positions(
    file_path: Path, randomize_position_order: bool = False
) -> tuple[np.ndarray, np.ndarray[Any, np.dtype[str]]]:
    """
    Extract stage positions from the JSON file generated by the
    Stage Position List in Micro-Manager.

    See https://micro-manager.org/Version_2.0_Users_Guide#stage-position-list.

    Parameters:
        file_path (Path): The path to the JSON file
        randomize_position_order (bool): If True, the order of the positions will be randomized.

    Returns:
        tuple[np.ndarray, np.ndarray[Any, np.dtype[str]]]: A tuple containing the XY coordinates
        as a numpy array and the labels as a list

    Raises:
        FileNotFoundError: If the stage position file is not found
    """

    print(f"Extracting stage positions from: {file_path}")
    # Load the JSON file
    with open(file_path) as file:
        data = json.load(file)

    # Extract the list of stage positions
    stage_positions = data["map"]["StagePositions"]["array"]

    # Extract (X, Y) coordinates and labels
    coordinates = []
    labels = []

    for position in stage_positions:
        # Get the position array from DevicePositions
        device_positions = position["DevicePositions"]["array"]
        for device in device_positions:
            xy_position = device["Position_um"]["array"]
            coordinates.append(xy_position)
            labels.append(position["Label"]["scalar"])

    # Convert coordinates to a numpy array of shape (N, 2) and labels to a numpy array
    coordinates_array = np.array(coordinates)
    labels = np.array(labels)

    if randomize_position_order:
        idx = np.random.permutation(len(labels))
        coordinates_array = coordinates_array[idx]
        labels = labels[idx]

    return coordinates_array, labels
