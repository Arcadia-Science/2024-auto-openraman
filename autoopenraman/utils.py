import csv
import json
from pathlib import Path
from typing import Iterable, Optional

import numpy as np

# Import calibration-related items from the dedicated module


def image_to_spectrum(img: np.ndarray) -> np.ndarray:
    """
    Convert 2D image to spectrum, assuming that averaging is done on the y-axis (second).

    Parameters:
        img (np.ndarray): A 2D image array

    Returns:
        np.ndarray: A 1D array representing the spectrum
    """

    # remove singleton dimensions, if any
    img = img.squeeze()
    # if 3d array, throw error
    if len(img.shape) != 2:
        raise ValueError(f"The input image should be a 2D array. It is a {len(img.shape)}D array.")

    return img.mean(axis=0)


def write_spectrum(
    file_path: Path,
    x: Iterable[float],
    y: Iterable[float],
    wavenumbers: Optional[Iterable[float]] = None,
    header: Optional[list] = None,
) -> None:
    """
    Write a CSV file of spectrum data with optional calibration.

    Parameters:
        file_path (str): The name of the file to write to.
        x (Iterable): An Iterable of pixel indices.
        y (Iterable): An Iterable of intensity values corresponding to each pixel.
        wavenumbers (Iterable, optional): Calibrated wavenumber values. If provided, a 3-column file
          is written.
        header (list, optional): A list of header values. Default depends on whether wavenumbers
          are provided.
    """
    # Check if the lengths of the arrays match
    if len(x) != len(y):
        raise ValueError("The length of x and y arrays must be the same.")

    # If wavenumbers are provided, ensure the length matches
    if wavenumbers is not None and len(wavenumbers) != len(x):
        raise ValueError("The length of wavenumbers array must match the x array.")

    # Set default header based on whether wavenumbers are provided
    if header is None:
        if wavenumbers is not None:
            header = ["Pixel", "Wavenumber (cm⁻¹)", "Intensity"]
        else:
            header = ["Pixel", "Intensity"]

    with open(file_path, mode="w", newline="") as file:
        writer = csv.writer(file)
        # Write the header
        writer.writerow(header)

        # Write the data rows
        if wavenumbers is not None:
            # 3-column format with calibration
            for pixel, wavenumber, intensity in zip(x, wavenumbers, y):
                writer.writerow([pixel, wavenumber, intensity])
        else:
            # 2-column format without calibration
            for pixel, intensity in zip(x, y):
                writer.writerow([pixel, intensity])


def extract_stage_positions(
    file_path: Path, randomize_position_order: bool = False
) -> tuple[np.ndarray, list[str]]:
    """
    Extract stage positions from the JSON file generated by the
    Stage Position List in Micro-Manager.

    See https://micro-manager.org/Version_2.0_Users_Guide#stage-position-list.

    Parameters:
        file_path (Path): The path to the JSON file
        randomize_position_order (bool): If True, the order of the positions will be randomized.

    Returns:
        tuple[np.ndarray, list[str]]: A tuple containing the XY coordinates
        as a numpy array and the labels as a list (because Pycromanager Acquisition requires labels
        as list).

    Raises:
        FileNotFoundError: If the stage position file is not found
    """

    print(f"Extracting stage positions from: {file_path}")
    # Load the JSON file
    with open(file_path) as file:
        data = json.load(file)

    # Extract the list of stage positions
    stage_positions = data["map"]["StagePositions"]["array"]

    # Extract (X, Y) coordinates and labels
    coordinates = []
    labels = []

    for position in stage_positions:
        # Get the position array from DevicePositions
        device_positions = position["DevicePositions"]["array"]
        for device in device_positions:
            xy_position = device["Position_um"]["array"]
            coordinates.append(xy_position)
            labels.append(position["Label"]["scalar"])

    # Convert coordinates to a numpy array of shape (N, 2) and labels to a numpy array
    coordinates_array = np.array(coordinates)
    labels = np.array(labels)

    if randomize_position_order:
        idx = np.random.permutation(len(labels))
        coordinates_array = coordinates_array[idx]
        labels = labels[idx]

    labels = labels.tolist()
    return coordinates_array, labels
